\chapter{عمل تطبيقي : \textenglish{Mario Sokoban}}

المكتبة
\textenglish{SDL}
تقدّم، مثلما رأينا، عددا كبيراً من الدوال الجاهزة للاستعمال. يمكن ألا نستطيع التعوّد عليها في البداية لقلّة التطبيق.

هذا العمل التطبيقي الأول في هذا الجزء من الكتاب سيعطيك فرصة التطبيق و اختبار أشياء لم تسنح لك فرصة تجريبها.
أعتقد أنه بإمكانك التخمين، فهذه المرة لن يكون التطبيق عبارة عن كونسول و إنما سيتحتوي على واجهة رسومية !

ماذا سيكون موضوع هذا العمل التطبيقي ؟ لعبة السوكوبان !\\
قد لا يعني لك هذا العنوان شيئاً، لكن هذه هي لعبة ذكاء تقليديّة. إنّها تنصّ على دفع صناديق لوضعها في أماكن محددة في متاهة.

\section{مواصفات \textenglish{Sokoban}}

\subsection{بخصوص \textenglish{Sokoban}}

الكلمة
"\textenglish{Sokoban}"
هي كلمة يابانية تعني "صاحب محلّ".\\
إنّها عبارة عن لعبة ذكاء تم اختراعها في الثمانينات بواسطة
\textenglish{Hiroyuki Imabayashi}.
و قد مثّلت برمجة هذه اللعبة تحدّيا كبيراً في ذلك الزمن.

\subsubsection{الهدف من اللعبة}

المبدأ بسيط : تقوم بتحريك شخصية في متاهة. يجدر بالشخصية أن تقوم بدفع صناديق إلى مواقع محددة. لا يمكن للاعب أن يدفع صندوقين في آن واحد.

حتى و إن كان المبدأ مفهوماً و بسيطاً، فهذا لا يعني أن اللعبة في حدّ ذاتها سهلة ! إذ أنه يجب عليك أحيانا تكسير رأسك بالتفكير لحلّ اللغز.

الصورة الموالية تُريك كيف تبدو اللعبة التي سنقوم ببرمجتها :

\Picture{Chapter_III-5_Mario-Sokoban}

\subsubsection{لماذا اخترتُ هذه اللعبة بالذات ؟}

لأنها لعبة شعبية، جيدة لأن تكون موضوعاً برمجياً و يمكننا إنشاؤها بواسطة ما تعلّمناه من الدروس السابقة.\\
يجب هنا أن نكون منظّمين. إذ أن الصعوبة لا تكمُن في برمجة اللعبة في حدّ ذاتها لكن في ما إن نظّمنا العمل. و لهذا فسنقوم بتقسيم البرنامج إلى عدّة ملفات
\InlineCode{.c}
بطريقة ذكيّة و نحاول إنشاء الدوال المناسبة.

من أجل هذا الأمر، قررت تغيير الطريقة بالنسبة لهذا العمل  التطبيقي : لن أقدّم لك توجيهات و أقدّم التصحيح في النهاية. بالعكس، سأريك كيف نقوم ببناء المشروع كلّه من الألف إلى الياء.

\begin{question}
ماذا لو كنتُ أريد التدرّب لوحدي ؟
\end{question}

حسناً إذا فلتنطلق لوحدك، هذا أمر جيد !\\
ستحتاج ربّما وقتاً أكثر : لقد استغرقت شخصيا يوماً كاملاً لبرمجة اللعبة، هذا ليس بالوقت الكثير ربّما لأنه جرت العادة أن أقوم بالبرمجة و و أن أتحاشى الوقوع في بعض الأفخاخ المتداولة (لكنّ هذا لم يمنعني من إعادة التفكير عدّة مرّات).

اِعلم بأنه توجد الكثير من الطرق التي يمكن بها برمجة هذه اللعبة. سأعطيك طريقتي في برمجتها : ليست أحسن طريقة و لكنها بالتأكيد ليست أسوء واحدة.\\
سننتهي من هذا التطبيق بقائمة من الإقتراحات لتحسين اللعبة، كما أنني سأعطيك الرابط لتحميل اللعبة و الشفرة المصدرية الكاملة.

أنصحك مجدداً أن تحاول برمجة اللعبة لوحدك، حتى لو استغرقت 3 أو 4 أيام. إفعل أحسن ما لديك. من المهم جدّا أن تقوم بالتطبيق.

\subsection{المواصفات}

المواصفات هي عبارة عن وثيقة نكتب فيها كل ما يجب على البرنامج أن يستطيع فعله.

هذا ما أقترحه :

\begin{itemize}
	\item يجب أن يتمكن اللاعب من التحرّك في المتاهة و دفع الصناديق.
	\item لا يمكنه أن يدفع صندوقين معاً.
	\item تُربح الجولة إذا تواجدت كلّ الصناديق في الأماكن المخصصة لها.
	\item سيتم حفظ كلّ مستويات اللعبة في ملف، (ليكن مثلا 
	\InlineCode{levels.lvl}).
	\item يجب أن يتم دمج مـُنشئ المستويات 
	(\textenglish{Levels editor})
	في البرنامج ليتمكن أي شخص كان من صنع مستويات خاصة به (هذا ليس أمراً ضرورياً لكنه يعتبر إضافة مميزة !).
\end{itemize}

هذا كافٍ لنعمل كثيراً.

يجب أن تعرف أنه هناك أشياء لا يجيد البرنامج القيام بها، و يجب ذِكرُ هذا الأمر أيضاً.

\begin{itemize}
	\item برنامجنا قادر على التحكّم في مرحلة واحدة في المرّة الواحدة. إن أردت أن تكون اللعبة عبارة عن تتالي جولات، فما عليك سوى برمجة ذلك بنفسك في نهاية هذا العمل التطبيقي.
	\item البرنامج لا يقوم بحساب الوقت المٌستغرق في كلّ جولة (نحن لا نجيد فعل ذلك بعد) و لا يمكنه حساب النقاط.
\end{itemize}

على أي حال، فكلّ الأشياء التي نريد القيام بها (خاصة مـُنشِئ المراحل) تأخذ منا وقتاً لابأس به.

\begin{information}
سأعطيك في نهاية العمل التطبيقي، جملة التحسينات التي تُمكن إضافتها إلى اللعبة. و هذه ليست كلمات في الهواء، لأنّها أفكار طبّقتها أنا شخصيّا في نسخة كاملة من اللعبة  سأقترح عليك تنزيلها.\\
بالمقابل، لن أعطيك الشفرة المصدرية الخاصة بالنسخة الكاملة لأنني أريدك أن تعمل بنفسك و تتدرّب (لن أعطيك كلّ شيء على طبق من فضّة !).
\end{information}

\subsection{الحصول على  الصور اللازمة لللعبة}

في معظم الألعاب ثنائية الأبعاد، أيّا كان نوعها، نسمّي الصور التي تشكّل اللعبة 
\textenglish{\textit{Sprites}}.\\
 في حالتنا، قرّرت إنشاء
\textenglish{Sokoban}
 و وضع الشخصية 
\textenglish{Mario}
لتكون اللاعب الرئيسي فيها (من هنا جاء اسم اللعبة 
\textenglish{Mario Sokoban}).
بما أن 
\textenglish{Mario}
شخصية لها شعبية كبيرة في عالم الألعاب 
\textenglish{2D}،
لن نتعب في الحصول على الـ\textenglish{sprites}
الخاصّة بهذه الشخصيّة. سنحتاج أيضا إلى
\textenglish{sprites}
خاصة بالجدران، الصناديق، الأماكن المستهدفة، إلخ.

إذا بحثت في
\textenglish{Google}
عن
"\textenglish{sprites}"
فستحصل على عدّة نتائج. توجد العديد من المواقع التي توفّر
\textenglish{sprites}
خاصّة بألعاب
\textenglish{2D}
قد تكون لعبتها في السابق.

و هذه هي الّتي سنحتاج إليها :

\begin{Table}{2}
\textenglish{Sprite} & الشرح\\
\includegraphics{Chapter_III-5_Wall}&
جدار\\
\includegraphics{Chapter_III-5_Box}&
صندوق\\
\includegraphics{Chapter_III-5_Box2}&
 صندوق متموضع فوق منطقة مستهدفة\\
\includegraphics{Chapter_III-5_Mario-down}&
بطل اللعبة
(\textenglish{Mario})
باتجاه الأسفل\\
\includegraphics{Chapter_III-5_Mario-right}&
بطل اللعبة باتجاه اليمين\\
\includegraphics{Chapter_III-5_Mario-left}&
بطل اللعبة باتجاه اليسار\\
\includegraphics{Chapter_III-5_Mario-up}&
بطل اللعبة باتجاه الأعلى\\
\end{Table}

الأسهل هو أن تقوم بتحميل الحزمة التي أعددتها لك.

\url{https://openclassrooms.com/uploads/fr/ftp/mateo21/sprites_mario_sokoban.zip}

\begin{information}
كان من الممكن أن أستعمل 
\textenglish{sprite}
واحداً خاصاً باللاعب. كان بإمكاني جعله موجّهاً إلى الأسفل فقط، لكن إضافة امكانية توجيهه في الإتجاهات الأربعة تضيف القليل من الواقعية. و هذا يشكّل تحدّيا آخر لنا !
\end{information}

قمت أيضاً بإنشاء صورة أخرى لتكون عبارة عن الواجهة الأساسية للعبة حين تبدأ، لقد أرفقت لك الصورة بالحزمة الّتي يفترض بك تنزيلها. لاحظ الصورة التالية :

\Picture{Chapter_III-5_Home}

ستلاحظ بأن الصور تأخذ صيغا مختلفة. يوجد منها ماهو
\textenglish{GIF}،
ماهو
\textenglish{PNG}
و حتى ماهو
\textenglish{JPEG}.
و لهذا فنحن بحاجة إلى استعمال المكتبة
\textenglish{SDL\_Image}.\\
فكّر في جعل مشروعك يعمل مع الـ\textenglish{SDL}
و الـ\textenglish{SDL\_Image}.
إذا نسيت كيف تفعل ذلك، فراجع الفصول السابقة. إذا لم تقم بتخصيص المشروع بشكل صحيح، سيشير المُترجم بأن الدوال التي تستعملها (مثل
\InlineCode{IMG\_Load})
غير موجودة !

\section{الدالة \texttt{main} و الثوابت}

في كلّ مرة نبدأ بتحقيق مشروع مهمّ، من الواجب أن نقوم بتنظيم العمل في البداية.\\
بشكل عام، أبدأ في إنشاء ملف ثوابت
\InlineCode{constants.h}
إضافة إلى ملف
\InlineCode{main.c}
يحتوي الدالة
\InlineCode{main}
(فقط هذه الدالة). هذه ليست قاعدة لكنها طريقتي الخاصة في العمل، و لكلّ شخص طريقته الخاصة.

\subsection{ملفّات المشروع المختلفة}

أقترح أن نقوم بإنشاء ملفات المشروع كلّه الآن، (حتى و إن كانت فارغة في البداية). هاهي الملفات التي أنشئها إذا :
\begin{itemize}
	\item \InlineCode{constants.h} :
	تعريف الثوابت الشاملة الخاصة بكل البرنامج.
	\item \InlineCode{main.c} :
	الملف الذي يحتوي
	\InlineCode{main}
	(الدالة الرئيسية في البرنامج).
	\item \InlineCode{game.c} :
	الدوال الّتي تسيّر جولة من اللعبة 
	\textenglish{Sokoban}.
	\item \InlineCode{game.h} :
	نماذج الدوال الخاصة بالملف 
	\InlineCode{game.c}.
	\item \InlineCode{editor.c} :
	ملف يحتوي الدول التي تتحكم في مـُنشئ المستويات.
	\item \InlineCode{editor.h} :
	نماذج الدوال الخاصة بالملف 
	\InlineCode{editor.c}.
	\item \InlineCode{files.c} :
	الدوال الخاصّة بقراءة و كتابة ملفّات المستويات (مثل
	\InlineCode{levels.lvl}).
	\item نماذج الدوال الخاصة بالملف 
	\InlineCode{files.c}.
\end{itemize}
سنبدأ بإنشاء ملف الثوابت.

\subsection{الثوابت : \texttt{constants.h}}

هذا محتوى الملف
\InlineCode{constants.h}
الخاص بي :

\begin{Csource}
/*
constants.h
------------

By mateo21, for "Site du Zéro" (www.siteduzero.com)

Role : define some constants for all of the program (window size...)
*/
#ifndef DEF_CONSTANTS
#define DEF_CONSTANTS
#define BLOCK_SIZE 34 // Block size (square) in pixels
#define NB_BLOCKS_WIDTH 12
#define NB_BLOCKS_HEIGHT 12
#define WINDOW_WIDTH BLOCK_SIZE * NB_BLOCKS_WIDTH
#define WINDOW_HIGHT BLOCK_SIZE * NB_BLOCKS_HEIGHT
enum {UP, DOWN, LEFT, RIGHT};
enum {EMPTY, WALL, BOX, GOAL, MARIO, BOX_OK};
#endif
\end{Csource}

ستلاحظ الكثير من النقاط المهمّة في هذا الملف الصغير.

\begin{itemize}
	\item يبدأ الملف بتعليق رأسي. أنصحك بوضع تعليق مماثل في كلّ ملفاتك (مهما كانت صيغتها
	\InlineCode{.c}
	أو
	\InlineCode{.h}).
	بشكل عام، التعليق الرأسي يحوي :
	\begin{itemize}
		\item اسم الملف،
		\item اسم الكاتب (المبرمج)،
		\item مهمّة الملف (أي فائدة الدوال الّتي يحويها)،
		\item لم أقم بهذا هنا، لكن عادة يفترض أيضاً إضافة تاريخ كتابة الملف و تاريخ آخر تعديل عليه. هذا يسمح لك بإيجاد المعلومات بسرعة حينما تحتاج إليها و خاصة حينما يتعلّق الأمر بمشاريع كبيرة.
	\end{itemize}
	\item الملف محمّي ضد التضمينات غير المنتهية. لقد استعملت لذلك التقنية التي تعلّمناها في نهاية فصل المعالج القبلي. هنا، الحماية ليست مهمّة جدّا، لكن جرت العادة أن أستعملها في كلّ ملفاتي
	\InlineCode{.h}
	بدون استثناء.
	\item أخيراً، قلب الملف. ستجد لائحة من 
	\InlineCode{\#define}.
	قمت بتحديد حجم كتلة بالبيكسل (كل
	\textenglish{sprites}
	هي عبارة عن مربّعات ذات حجم 34 بيكسل). أحدد بأن حجم النافذة يساوي 12*12 كتلة كعُرض. و بهذا أقوم بحساب أبعاد النافذة بعملية ضرب ثوابت بسيطة. ما أقوم به هنا ليس ضرورياً، لكنه يعود علينا بالفائدة : إذا أردت لاحقاً مراجعة حجم اللعبة، يكفي أن أقوم بتعديل هذا الملف و إعادة ترجمة المشروع فيعمل مع القيم الجديدة دون أية مشاكل.
	\item أخيراً، قمت بتعريف ثوابت عن طريق تعدادات غير معرّفة، الأمر مختلف قليلاً عمّا تعلّمناه في فصل إنشاء أنواع خاصة بنا. هنا أنا لست أقوم بتعريف نوع خاص بي بل أقوم فقط بتعريف ثوابت. هذا يشبه المعرّفات مع اختلاف بسيط : الحاسوب هو من يقوم بإعطاء عدد لكلّ قيمة (بدءً من 0). و بهذا يكن لدينا : 
	\InlineCode{UP} = 0،
	\InlineCode{DOWN} = 1،
	\InlineCode{LEFT} = 2،
	إلخ. هذا ما سيسمح للشفرة بأن تكون مفهومة لاحقاً، سترى ذلك !
\end{itemize}

باختصار، لقد استعملت :

\begin{itemize}
	\item معرّفات حينما أريد أن أعطي قيمة محددة لثابت (مثلاً 34 بيكسل).
	\item تعدادات حينما تكون قيمة الثابت لا تهمّني. هنا، لا يهمني ما إن كانت القيمة المُرفقة بالعنصر
	\InlineCode{UP}
	هي 0 (كان من الممكن أن تكون 150، هذا لن يغييّر شيئا)، كلّ ما يهمّني هو أن يكون هذا العنصر مختلفا عن
	\InlineCode{DOWN}
	و
	\InlineCode{LEFT}
	و
	\InlineCode{RIGHT}.
\end{itemize}

\subsubsection{تضمين تعريفات الثوابت}

المبدأ ينص على تضمين ملف الثوابت في كلّ الملفات
\InlineCode{.c}.\\
هكّذا، أستطيع استعمال الثوابت في أي مكان من الشفرة المصدرية الخاصة بالمشروع.

يعني أنه عليّ أن أكتب السطر التالي في كل بداية للملفات 
\InlineCode{.c} :

\begin{Csource}
#include "constants.h"
\end{Csource}

\subsection{الدالة \texttt{main} : \texttt{main.c}}

الدالة الرئيسيّة الخاصة بالبرنامج سهلة جداً. هي تقوم بإظهار واجهة اللعبة ثم التوجيه إلى القِسم المناسب.

\begin{Csource}
/*
main.c
------

By mateo21, for "Site du Zéro" (www.siteduzero.com)

Role : game menu. Allow to choose between the editor and the game.
*/
#include <stdlib.h>
#include <stdio.h>
#include <SDL/SDL.h>
#include <SDL/SDL_image.h>
#include "constants.h"
#include "game.h"
#include "editor.h"
int main(int argc, char *argv[])
{
	SDL_Surface *screen = NULL, *menu = NULL;
	SDL_Rect menuPosition;
	SDL_Event event;
	int cont = 1;
	SDL_Init(SDL_INIT_EMPTYO);
	SDL_WM_SetIcon(IMG_Load("box.jpg"), NULL); // The icon must be loaded before SDL_SetVideoMode
	screen = SDL_SetVideoMode(WINDOW_WIDTH, WINDOW_HIGHT, 32,SDL_HWSURFACE | SDL_DOUBLEBUF);
	SDL_WM_SetCaption("Mario Sokoban", NULL);
	menu = IMG_Load("menu.jpg");
	menuPosition.x = 0;
	menuPosition.y = 0;
	while (cont)
	{
		SDL_WaitEvent(&event);
		switch(event.type)
		{
			case SDL_QUIT:
			cont = 0;
			break;
			case SDL_KEYDOWN:
			switch(event.key.keysym.sym)
			{
				case SDLK_ESCAPE: // Want to quit the game
				cont = 0;
				break;
				case SDLK_KP1: // Want to play
				play(screen);
				break;
				case SDLK_KP2: // Want to edit levels
				editor(screen);
				break;
			}
			break;
		}
		// Cleaning the screen
		SDL_FillRect(screen, NULL, SDL_MapRGB(screen->format, 0, 0,0));
		SDL_BlitSurface(menu, NULL, screen, &menuPosition);
		SDL_Flip(screen);
	}
	SDL_FreeSurface(menu);
	SDL_Quit();
	return EXIT_SUCCESS;
}
\end{Csource}

الدالة
\InlineCode{main}
تتكفّل بتهيئة الـ\textenglish{SDL}،
و إعطاء عنوان للنافذة إضافة إلى منحها أيقونة. في نهاية الدالة، يتم استدعاء الدالة 
\InlineCode{SDL\_Quit}
 لإيقاف الـ\textenglish{SDL}
بشكل سليم.

الدالة تقوم بإظهار قائمة يتم تحميلها بواسطة الدالة 
\InlineCode{IMG\_Load}
من المكتبة
\textenglish{SDL\_Image}.

\begin{Csource}
menu = IMG_Load("menu.jpg");
\end{Csource}

تلاحظ أنه، لكي أعطي أبعاداً للنافذة، أستعمل الثابتين
\InlineCode{WINDOW\_WIDTH}
و
\InlineCode{WINDOW\_HIGHT}
المعرّفين في الملف
\InlineCode{constants.h}.

\subsubsection{حلقة الأحداث}

الحلقة غير المنتهية تعالج الأحداث التالية :

\begin{itemize}
	\item \textbf{إيقاف البرنامج}
	(\InlineCode{SDL\_QUIT}) :
	إذا قمنا بطلب غلق البرنامج (النقر على العلامة
	\InlineCode{X}
	أعلى يمين النافذة) فسنعطي القيمة 0 للمتغير
	\InlineCode{cont}
	و تتوقف الحلقة. باختصار، هذا أمر تقليديّ.
	\item \textbf{الضغط على الزر
		\InlineCode{Escape}} :
	إغلاق البرنامج (مثل
	\InlineCode{SDL\_QUIT}).
	\item \textbf{الضغط على الزر
	\InlineCode{1}
	من لوحة الأرقام} :
	إنطلاق تشغيل اللعبة (استدعاء الدالة 
	\InlineCode{play}).
	\item \textbf{الضغط على الزر
	\InlineCode{2}
	من لوحة الأرقام} :
	إنطلاق تشغيل مُنشئ المراحل (استدعاء الدالة
	\InlineCode{editor}).
\end{itemize}

كما ترى فالأمور تجري بسهولة تامة. إذا ضغطنا على الزر 1، يتم تشغيل اللعبة، ما إن تنتهي اللعبة، تنتهي الدالة
\InlineCode{play}
و نرجع للـ\InlineCode{main}
من أجل القيام بدورة أخرى للحلقة. الحلقة تستمر في الاشتغال مادمنا لم نطلب إيقاف البرنامج.

بفضل هذا التنظيم البسيط جدّا، يمكننا التحكم في الدالة
\InlineCode{main}
و ترك الدوال الأخرى (مثل
\InlineCode{play}
و
\InlineCode{editor})
تهتم بالتحكم في مختلف أجزاء اللعبة.

\section{اللعبة}

فلندخل إلى المرحلة الأكثر أهمية في الموضوع : الدالة 
\InlineCode{play} !\\
هذه هي الدالة الأكثر أهمية في البرنامج، كن متيقّظاً لأن هذه الدالة هي حقّا ما يجدر بك فهمه. لأنك ستجد بعدها بأن مُنشئ المراحل ليس بالصعوبة التي تتخيّلها.

\subsection{المعاملات التي نبعثها للدالة}

الدالة
\InlineCode{play}
تحتاج إلى معامل واحد : المساحة
\InlineCode{screen}.
بالفعل، تم فتح النافذة في الدالة الرئيسية، و لكي تستطيع الدالة
\InlineCode{play}
أن ترسم على النافذة، يجب أن تقوم باسترجاع المؤشّر نحو المساحة
\InlineCode{screen} !

لو تقرأ مجدداً محتوى الدالة الرئيسية، ستجد بأنني قمت باستدعاء الدالة
\InlineCode{play}
و ذلك بإعطائها المؤشّر
\InlineCode{screen} :

\begin{Csource}
play(screen);
\end{Csource}

نموذج الدالة، الذي يمكنك وضعه في الملف
\InlineCode{game.h}،
هو التالي :

\begin{Csource}
void play(SDL_Surface* screen);
\end{Csource}

\begin{information}
الدالة لا تقوم بإرجاع أي شيء (و من هنا الـ\InlineCode{void}).
يمكننا أن نجعلها إن أردنا تُرجع قيمة منطقية تشير إلى ما كنّا قد ربحنا الجولة أم لا.
\end{information}

\subsection{التصريح عن المتغيرات}

تحتاج هذه الدالة إلى كثير من المتغيرات.\\
لم أفكّر في كلّ المتغيرات التي أحتاجها من الوهلة الأولى. هناك من أضفتها لاحقاً و أنا أكتب الشفرة.

\subsubsection{متغيّرات من أنواع معرّفة في الـ\textenglish{SDL}}

لكي نبدأ، هاهي كلّ المتغيرات ذات الأنواع المعرّفة في الـ\textenglish{SDL}
التي نحن بحاجة إليها :

\begin{Csource}
SDL_Surface *mario[4] = {NULL}; // 4 surfaces for the 4 directions of mario
SDL_Surface *wall = NULL, *box = NULL, *boxOK = NULL, *objective = NULL, *level= NULL, *currentMario = NULL;
SDL_Rect position, playerPosition;
SDL_Event event;
\end{Csource}

لقد قمتُ بإنشاء جدول من نوع 
\InlineCode{SDL\_Surface}
يسمّى 
\InlineCode{mario}.
و هو جدول من أربع خانات يقوم بتخزين 
\textenglish{Mario}
في كلّ من الاتجاهات الأربعة (واحد للأسفل، الأعلى، اليمين و اليسار).

توجد بعد ذلك العديد من المساحات الموافقة لكلّ من 
\textenglish{sprites}
التي قمت بتحميلها أعلاه : 
\InlineCode{wall}،
\InlineCode{box}،
\InlineCode{boxOK}
و
\InlineCode{objective}.

\begin{question}
بماذا ينفعنا
\InlineCode{currentMario} ؟
\end{question}

هو عبارة عن مؤشّر نحو مساحة. و هو مؤشّر يؤشّر نحو المساحة الموافقة لـ\textenglish{Mario}
المتّجه نحو الإتجاه الحالي. أي أنه عبارة عن 
\InlineCode{currentMario}
(\textenglish{Mario}
الحالي) الّذي سنقوم بتسويته في الشاشة. إذا رأيت في أسفل الدالة
\InlineCode{play}
ستجد :
\begin{Csource}
SDL_BlitSurface(currentMario, NULL, screen, &position);
\end{Csource}

لا نقوم إذا بلصق عنصر من الجدول
\InlineCode{mario}،
بل المؤشّر
\InlineCode{currentMario}.\\
و بلصق 
\InlineCode{currentMario}،
يعني أننا سنلصق إما
\textenglish{Mario}
نحو الأسفل، أو نحو الأعلى، إلخ.\\
المؤشّر
\InlineCode{currentMario}
يؤشّر نحو إحدى خانات الجدول
\InlineCode{mario}.

ماذا بعد غير هذا ؟\\
متغير
\InlineCode{position}
من نوع
\InlineCode{SDL\_Rect}
سنستعين به من أجل تعريف موضع العناصر التي سنقوم بتسويتها (سنحتاج إليها من أجل كلّ الـ\textenglish{sprites}،
و لا داعي لإنشاء
\InlineCode{SDL\_Rect}
من أجل كلّ مساحة !).
المتغير
\InlineCode{playerPosition}
مختلف : إنه يشير إلى أية خانة من الخريطة يوجد اللاعب. أخيراً، المتغير
\InlineCode{event}
يهتم بتحليل الأحداث.

\subsubsection{متغيّرات "تقليديّة"}

حان الوقت لكي أعرّف متغيرات تقليديّة نوعاً ما من نوع 
\InlineCode{int} :

\begin{Csource}
int cont = 1, remainingGoals = 0, i = 0, j = 0;
int map[NB_BLOCKS_WIDTH][NB_BLOCKS_HEIGHT] = {0};
\end{Csource}

\InlineCode{cont}
و 
\InlineCode{remainingGoals}
هي متغيرات منطقية.\\
\InlineCode{i}
و
\InlineCode{j}
هي متغيرات مُساعِدة ستساعدنا في قراءة الجدول 
\InlineCode{map}.

هنا تبدأ الأمور الهامّة حقّا. لقد قمت فعلياً بإنشاء جدول ذو بُعدين. لم أكلّمك عن هذا النوع من الجداول من قبل، لكنه الوقت المناسب لتتعلّم ما يعنيه. ليس الأمر صعباً، سترى ذلك بنفسك.

لاحظ التعريف عن كثب :

\begin{Csource}
int map[NB_BLOCKS_WIDTH][NB_BLOCKS_HEIGHT] = {0};
\end{Csource}

هو عبارة عن جدول من 
\InlineCode{int}
(أعداد صحيحة) يختلف في كونه يأخذ حاضنتين مربّعتين
\InlineCode{[ ]}.
إذا كنت تتذكر جيداً الملف 
\InlineCode{constants.h}،
 فـ\InlineCode{NB\_BLOCKS\_WIDTH}
و
\InlineCode{NB\_BLOCKS\_HEIGHT}
هما ثابتين يأخذ كلاهما القيمة 12.

هذا الجدول سيتمّ إنشاءه في وقت الترجمة هكذا :

\begin{Csource}
int map[12][12] = {0};
\end{Csource}

\begin{question}
لكن، ماذا يعني هذا ؟
\end{question}

هذا يعني أنه من أجل كلّ "خانة" من
\InlineCode{map}
توجد 12 خانة داخلية.\\
بهذا تكون لدينا المتغيرات التالية :

\begin{Console}
map[0][0]
map[0][1]
map[0][2]
map[0][3]
map[0][4]
map[0][5]
map[0][6]
map[0][7]
map[0][8]
map[0][9]
map[0][10]
map[0][11]
map[1][0]
map[1][1]
map[1][2]
map[1][3]
map[1][4]
map[1][5]
map[1][6]
map[1][7]
map[1][8]
map[1][9]
map[1][10]
...
map[11][2]
map[11][3]
map[11][4]
map[11][5]
map[11][6]
map[11][7]
map[11][8]
map[11][9]
map[11][10]
map[11][11]
\end{Console}

إذا هو جدول من 12 * 12 = 144 خانة !\\
كلّ من هذه الخانات تمثّل خانة في خريطة اللعبة.

الصورة التالية تعطيك فكرة كيف قُمنا بتمثيل الخريطة  :

\Picture{Chapter_III-5_Map}

و بهذا فالخانة في أعلى اليسار مخزّنة في
\InlineCode{map[0][0]}.\\
الخانة أعلى اليمين مخزنة في
\InlineCode{map[0][11]}.\\
الخانة أسفل اليمين (آخر خانة) مخزنة في
\InlineCode{map[11][11]}.

حسب قيمة الخانة (و التي هي عدد صحيح)، نعرف أي خانة من النافذة تحتوي جداراً، أو صندوقاً، أو منطقة مستهدفة، إلخ.\\
هنا بالضبط سنستفيد من تعريف التعداد السابق !

\begin{Csource}
enum {EMPTY, WALL, BOX, GOAL, MARIO, BOX_OK};
\end{Csource}

إذا كانت قيمة الخانة تساوي
\InlineCode{EMPTY} (0)
سنعرف بأن هذه المنطقة من الشاشة يجب أن تبقى بيضاء. إذا كانت تساوي
\InlineCode{WALL} (1)
فسنعرف أنه يجب أن نقوم بلصق صورة جدار، إلخ.

\subsection{تهيئات}

\subsubsection{تحميل المساحات}

و الآن، بما أننا قمنا بشرح كل متغيرات الدالة
\InlineCode{play}،
يمكننا البدء في القيام ببعض التهيئات :

\begin{Csource}
// Loading the sprites (Boxes, player...)
wall = IMG_Load("wall.jpg");
box = IMG_Load("box.jpg");
boxOK = IMG_Load("box_ok.jpg");
level = IMG_Load("level.png");
mario[DOWN] = IMG_Load("mario_bas.gif");
mario[LEFT] = IMG_Load("mario_gauche.gif");
mario[UP] = IMG_Load("mario_haut.gif");
mario[RIGHT] = IMG_Load("mario_droite.gif");
\end{Csource}

لا يوجد شيء صعب : نقوم بتحميل الكلّ بواسطة 
\InlineCode{IMG\_Load}.\\
إن كانت هناك حالة خاصّة، فهي تحميل
\textenglish{Mario}.
 إذ أننا نقوم بتحميل 
\textenglish{Mario}
 في كلّ من الإتّجاهات الأربعة في الجدول
\InlineCode{mario}
باستعمال الثوابت : 
\InlineCode{UP}، \InlineCode{DOWN}، \InlineCode{LEFT}، \InlineCode{RIGHT}.
كوننا استعملنا هنا ثوابت فستصبح الشفرة أكثر وضوحاً -كما تلاحظ- . كان بإمكاننا استعمال
\InlineCode{mario[0]}،
لكن من الأفضل و من الأكثر وضوحاً أن نستعمل
\InlineCode{mario[UP]}
مثلاً !

\subsubsection{التوجيه الابتدائيّ لـ\textenglish{Mario} (\texttt{currentMario})}

نهيّئ بعدها
\InlineCode{currentMario}
لكيّ تكون له وجهة ابتدائيّة :
\begin{Csource}
currentMario = mario[DOWN]; // Mario will be headed down when starting the program
\end{Csource}

وجدت أنه من المنطقي أكثر أن أبدأ المرحلة فيما يكون ماريو موجّها نحو الأسفل (أي نحونا)، كان بامكانك أن تكتب مثلاً :

\begin{Csource}
currentMario = mario[RIGHT];
\end{Csource}

ستُلاحظ بأن
\textenglish{Mario}
سيكون موجّهاً نحو اليمين في بداية اللعبة.

\subsubsection{تحميل الخريطة}

الآن، يجدر بنا ملئ الجدول ثنائي الأبعاد
\InlineCode{map}.
لحدّ الآن، الجدول لا يحتوي إلا أصفاراً.\\
يجب أن نقرأ المستوى المخزّن في الملف
\InlineCode{levels.lvl} :

\begin{Csource}
// Loading the level
if (!loadLevel(map))
	exit(EXIT_FAILURE); // We stop the game if we couldn't load the level
\end{Csource}

لقد اخترت معالجة تحميل (و حفظ) المستويات بواسطة دوال متواجدة بالملف
\InlineCode{files.c}.\\
هنا ، نستدعي إذا الدالة
\InlineCode{loadLevel}.
سنقوم بدراستها بالتفصيل لاحقا (هي ليست معقدة كثيراً على أي حال). كل ما يهمنا هنا هو معرفة أنه تم تحميل المستوى في الجدول
\InlineCode{map}.

\begin{critical}
إذا لم يتم تحميل المستوى (لأن ملف
\InlineCode{levels.lvl}
غير موجود)، ستُرجع الدالة "خطأ". أمّا في الحالة المعاكسة فتُرجع "صحيح".
\end{critical}

نقوم إذا باختبار نتيجة التحميل بواسطة شرط. إذا كانت النتيجة سلبية (من هنا استعملت إشارة التعجّب لأعبّر عن ضدّ الشرط) يتوقف كلّ شيء : : سنستدعي الدالة 
\InlineCode{exit}.\\
في الحالة الأخرى، كلّ شيء يعمل بشكل جيّد إذاً و يمكننا المواصلة.

نحن نملك الآن جدولا
\InlineCode{map}
يصف محتوى كلّ خانة : 
\InlineCode{WALL}، \InlineCode{EMPTY}، \InlineCode{BOX}\dots

\subsubsection{البحث عن وضعية الإنطلاق لـ\textenglish{Mario}}

يجب الآن أن نعطي قيمة ابتدائية للمتغير
\InlineCode{playerPosition}.\\
هذا المتغير من نوع
\InlineCode{SDL\_Rect}
خاصّ قليلاً. لن نستعين به لتخزين الإحداثيات بالبيكسل و إنما بتخزينه بدلالة الـ"خانات" في الخريطة. و بهذا فإن كانت لدينا :

\InlineCode{playerPosition.x == 11}
و
\InlineCode{playerPosition.y == 11}

فهذا يعني أن اللاعب متواجد في آخر خانة في أسفل يمين الخريطة.\\
يمكنك الرجوع إلى الصورة السابقة لتتوضح لك الأمور أكثر.

سنقوم بالتقدّم داخل الجدول
\InlineCode{map}
و ذلك باستعمال حلقتين. نستعمل المتغير
\InlineCode{i}
للتقدّم في الجدول عمودياً، و نستعمل المتغير
\InlineCode{j}
للتقدّم فيه أفقياً :

\begin{Csource}
// We search for the position of Mario in the beginning of the game
for (i = 0 ; i < NB_BLOCKS_WIDTH ; i++)
{
	for (j = 0 ; j < NB_BLOCKS_HEIGHT ; j++)
	{
		if (map[i][j] == MARIO) // If Mario is in this position
		{
			playerPosition.x = i;
			playerPosition.y = j;
			map[i][j] = EMPTY;
		}
	}
}
\end{Csource}

في كلّ خانة، نختبر ما إن كانت هذه الأخيرة تحتوي
\InlineCode{MARIO}
(أي نقطة انطلاق اللاعب في الخريطة). إذا كانت كذلك، نقوم بتخزين الإحداثيات الحالية (المتواجدة في 
\InlineCode{i}
و
\InlineCode{j})
في المتغير
\InlineCode{playerPosition}.\\
نمسح أيضاً الخانة و ذلك بإعطائها القيمة
\InlineCode{EMPTY}
لكي يتم اعتبارها كخانة فارغة لاحقاً.

\subsubsection{تفعيل تكرار الضغط على الأزرار}

آخر شيء، أمر سهل جداً : سنقوم بتفعيل تكرار الضغط على الأزرار لكي نستطيع التحرّك في الخريطة بترك الزر مضغوطاً.

\begin{Csource}
// Enabeling keys repetition
SDL_EnableKeyRepeat(100, 100);
\end{Csource}

\subsection{الحلقة الرئيسية}

حسناً، لقد قُمنا بتهيئة كلّ شيء، يمكننا الآن العمل على الحلقة الرئيسية.

إنها حلقة تقليديّة تعمل بنفس المخطط الذي تعمل به الحلقات التي رأيناها لحدّ الآن. هي فقط كبيرة قليلاً.

فلنرى عن قرب الـ\InlineCode{switch}
الذي يختبر الحدَث :

\begin{Csource}
switch(event.type)
{
	case SDL_QUIT
	cont = 0;
	break;
	case SDL_KEYDOWN:
	switch(event.key.keysym.sym)
	{
		case SDLK_ESCAPE:
		cont = 0;
		break;
		case SDLK_UP:
		currentMario = mario[UP];
		movePlayer(map, &playerPosition, UP);
		break;
		case SDLK_DOWN:
		currentMario = mario[DOWN];
		movePlayer(map, &playerPosition, DOWN);
		break;
		case SDLK_RIGHT:
		currentMario = mario[RIGHT];
		movePlayer(map, &playerPosition, RIGHT);
		break;
		case SDLK_LEFT:
		currentMario = mario[LEFT];
		movePlayer(map, &playerPosition, LEFT);
		break;
	}
	break;
}
\end{Csource}

إذا ضغطنا على الزر
\InlineCode{Esc}،
فستنتهي اللعبة و نرجع للقائمة الرئيسية.

كما ترى، لا توجد العديد من الأحداث لنعالجها : سنختبر فقط ما إن ضغط اللاعب على الأزرار "أعلى"، "أسفل"،"يمين" أو "يسار" من لوحة المفاتيح.\\
على حسب الزر المضغوط نغيّر اتجاه 
\textenglish{Mario}.
 و هنا يتدخّل المتغير 
\InlineCode{currentMario} !
 إذا ضغطنا السهم الموجه نحو الأعلى إذاً :

\begin{Csource}
currentMario = mario[UP];
\end{Csource}

إذا ضغطنا على السهم الموجّه نحو الأسفل فإذاً :

\begin{Csource}
currentMario = mario[DOWN];
\end{Csource}

الآن، شيء مهمّ جداً : نستدعي الدالة
\InlineCode{movePlayer}.
هذه الدالة ستقوم بتحريك اللاعب في الخريطة إن كان له الحق في فعل ذلك.

\begin{itemize}
	\item مثلاً، لا يمكننا أن نُحرك 
	\textenglish{Mario}
	إلى الأعلى إن كان متواجداً أصلاً في الحافة العلوية للنافذة.
	\item لا يمكننا أيضاً أن نحرّكه للأعلى إن كان فوقه جدار.
	\item لا يمكننا أن نحرّكه للأعلى إن كان فوقه صندوقان.
	\item على العكس، يمكننا تحريكه للأعلى إن تواجد صندوق واحد فوقه.
	\item لكن احذر، لا يمكننا تحريكه للأعلى إن تواجد صندوق واحد فوقه و كان هذا الصندوق متواجد أصلاً في الحافة العلوية للنافذة !
\end{itemize}

\begin{question}
يا إلاهي، ماهذا السوق ؟
\end{question}

هذا ما نسمّيه بـ
\textbf{معالجة الاصطدامات}
(\textenglish{Collisions management}).
و لكي أضمن لك، نحن نقوم بالتعامل مع الاصطدامات البسيطة بما أن اللاعب يتحرّك خانة بخانة و في أربع اتجاهات فقط. في لعبة ثنائية الأبعاد أين يتحرّك اللاعب في كلّ الاتجاهات بيكسلا ببيكسل، يكون التحكّم في الاصطدامات أمرا أصعب. 

لكن هناك ماهو أسوء : الألعاب ثلاثية الأبعاد. التحكم في الإصطدامات في لعبة ثلاثية الأبعاد يُعدّ كابوساً بالنسبة للمبرمجين. لحسن الحظ، توجد مكتبات للتحكّم في الاصطدامات في العوالم ثلاثية الأبعاد و التي تقوم بالكثير من العمل في مكاننا.

لنرجع للدالة
\InlineCode{movePlayer}
و لنركّز . نقوم بإعطائها ثلاثة معاملات :

\begin{itemize}
	\item الخريطة : لكي تستطيع قراءتها و أيضاً التعديل عليها إذا قمنا بتحريك صندوق مثلاً.
	\item وضعية اللاعب : هنا أيضاً، يجب على الدالة قراءة و "ربما" تعديل وضعية اللاعب.
	\item الإتجاه الذي نطلب من اللاعب التوجّه إليه : نستعمل هنا أيضاً الثوابت :
	\InlineCode{UP}، \InlineCode{DOWN}، \InlineCode{LEFT}، \InlineCode{RIGHT}
	من أجل فهم الشفرة بشكل أفضل.
\end{itemize}

سندرس الدالة
\InlineCode{movePlayer}
لاحقاً. كان بإمكاني وضع كلّ الاختبارات داخل الـ\InlineCode{switch}،
لكن بهذا سيصبح كبيراً و ستصعب علينا قراءته. و من هنا نرى الفائدة من تقسيم الشفرة إلى عدّة دوال.

\subsubsection{التسوية، فلنسوّي كلّ شيء}

لقد انتهينا من الـ\InlineCode{switch} :
في هذه الوضعية من البرنامج، قد تكون الخريطة قد تغيّرت و كذا وضعية اللاعب. مهما كان، لقد حان وقت التسوية !

سنبدأ بمسح الشاشة و ذلك بإعطائها لون خلفية أبيض :

\begin{Csource}
// Clearing the screen
SDL_FillRect(screen, NULL, SDL_MapRGB(screen->format, 255, 255, 255));
\end{Csource}

و الآن، نقوم بالتقدّم في الجدول ذو البعدين 
\InlineCode{map}
لكي نعرف أي عنصر سنقوم بتسويته و في أي منطقة من الشاشة.\\
سنستعمل حلقتين كما رأينا سابقاً للتقدّم في الـ144 خانة من الجدول :

\begin{Csource}
// Placing the objects on the screen
remainingGoals = 0;
for (i = 0 ; i < NB_BLOCKS_WIDTH ; i++)
{
	for (j = 0 ; j < NB_BLOCKS_HEIGHT ; j++)
	{
		position.x = i * BLOCK_SIZE;
		position.y = j * BLOCK_SIZE;
		switch(map[i][j])
		{
			case WALL:
			SDL_BlitSurface(wall, NULL, screen, &position);
			break;
			case BOX:
			SDL_BlitSurface(box, NULL, screen, &position);
			break;
			case BOX_OK:
			SDL_BlitSurface(boxOK, NULL, screen, &position);
			break;
			case GOAL:
			SDL_BlitSurface(level, NULL, screen, &position);
			remainingGoals = 1;
			break;
		}
	}
}
\end{Csource}

من أجل كل خانة، نحضّر المتغير
\InlineCode{position}
(من نوع
\InlineCode{SDL\_Rect})
لكي نضع العنصر الحالي في المكان المناسب من الشاشة.\\
العملية جدّ بسيطة :

\begin{Csource}
position.x = i * BLOCK_SIZE;
position.y = j * BLOCK_SIZE;
\end{Csource}

يكفي ضرب
\InlineCode{i}
بـ\InlineCode{BLOCK\_SIZE}
لكي نعرف قيمة
\InlineCode{position.x}.\\
و بهذا، فإن كنا نتواجد في الخانة الثالثة، أي أن
\InlineCode{i} = 2
(لا تنس أن
\InlineCode{i}
يبدأ من 0 !)، نقوم إذاً بالعملية
\mbox{2 * 34 = 68}.
 إذا نقوم بلصق الصورة 68 بيكسلا نحو اليمين في المساحة 
\InlineCode{screen}.\\
نقوم بنفس الشيء بالنسبة للترتيبة
\InlineCode{y}.

بعد ذلك، نطبّق
\InlineCode{switch}
على الخانة التي نقوم بتحليلها من الخريطة.\\
هنا أيضاً، استعمال الثوابت يعتبر شيئاً عملياً و يسمح بقراءة مُثلى للشفرة.\\
نختبر إذا ما إن كانت الخانة تساوي
\InlineCode{WALL}،
في هذه الحالة نقوم بلصق جدار. نفس الشيء بالنسبة للصناديق و المناطق المُستهدفة.

\subsubsection{اختبار الفوز}

تلاحظ أنه قبل استعمال الحلقتين المتداخلتين، نعطي القيمة الإبتدائية 0 للمتغير المنطقي
\InlineCode{remainingGoals}.\\
هذا المتغير المنطقي يأخذ القيمة 1 ما إن نقوم بكشف منطقة مُستهدفة على الخريطة. حينما لا تتبقّى أية منطقة مستهدفة، فهذا يعني أن كل الصناديق متواجدة فوق هذه المناطق (لم تتبقّ سوى صناديق
\InlineCode{BOX\_OK}).

يكفي أن نختبر ما إن كان المتغير المنطقي يحمل القيمة "خطأ"، أي أنه لم تتبقّ أية منطقة مستهدفة.\\
في هذه الحالة، نُعطي القيمة 0 للمتغير
\InlineCode{cont}
من أجل إيقاف الجولة :

\begin{Csource}
// If there's no remaining goal, we win
if (!remainingGoals)
	cont = 0;
\end{Csource}

\subsubsection{اللاعب}

لم يتبقّ سوى تسوية اللاعب :

\begin{Csource}
// We place the player in the right position
position.x = playerPosition.x * BLOCK_SIZE;
position.y = playerPosition.y * BLOCK_SIZE;
SDL_BlitSurface(currentMario, NULL, screen, &position);
\end{Csource}

نحسُب وضعيته (بالبيكسل هذه المرة) و ذلك بالقيام بعملية ضرب بين
\InlineCode{playerPosition}
و
\InlineCode{BLOCK\_SIZE}.
بعد ذلك، نقوم بلصق اللاعب في الوضعية المناسبة.

\subsubsection{القلب !}

لقد قُمنا بكلّ شيء، يكفي أن نُظهر الشاشة للمستعمل :

\begin{Csource}
SDL_Flip(screen);
\end{Csource}

\subsection{نهاية الدالة : إلغاء التحميل}

بعد الحلقة الرئيسية، يجدر بنا القيام بتحرير الذاكرة التي حجزناها للـ\InlineCode{sprites}
التي حمّلناها.\\
نقوم أيضا بتعطيل تكرار الضغط على الأزرار و ذلك بإعطاء القيمة 0 للدالة
\InlineCode{SDL\_EnableKeyRepeat} :

\begin{Csource}
// Disabling keys repetition (reset to 0)
SDL_EnableKeyRepeat(0, 0);
// Freeing the used surfaces
SDL_FreeSurface(wall);
SDL_FreeSurface(box);
SDL_FreeSurface(boxOK);
SDL_FreeSurface(level);
for (i = 0 ; i < 4 ; i++)
	SDL_FreeSurface(mario[i]);
\end{Csource}

\subsection{الدالة \texttt{movePlayer}}

هذه الدالة متواجدة أيضاً في الملف 
\InlineCode{game.c}.
هي دالة \dots معقّدة جدّا من ناحية كتابتها. و ربّما هي الدالة الأكثر صعوبة حينما نريد برمجة لعبة
\textenglish{Sokoban}.

\paragraph{تذكير :}
الدالة
\InlineCode{movePlayer}
تختبر ما إن كان لدينا الحق في تحريك اللاعب في الإتجاه المطلوب. تقوم بتحديث وضعية اللاعب
\InlineCode{playerPosition}
و أيضاً بتحديث الخريطة إذا تم تحريك صندوق.

هذا نموذج الدالة :

\begin{Csource}
void movePlayer(int map[][NB_BLOCKS_HEIGHT], SDL_Rect *pos,int direction);
\end{Csource}

هذا النموذج خاص قليلاً. تلاحظ أنني أبعث الجدول
\InlineCode{map}
و أحدد الحجم الخاص بالبُعد الثاني\\
(\InlineCode{NB\_BLOCKS\_HEIGHT}).\\
لماذا هذا ؟

الإجابة معقّدة قليلاً لكي أقوم بمناقشتها في وسط هذا الدرس. لكي نبسّط الأمور، لغة الـ\textenglish{C}
لا تتكهّن بأننا نتحدّث عن جدول ثنائي الأبعاد و أنه يجب أن نعطي على الأقل حجم البُعد الثاني لكي تشتغل الأمور.\\
إذا، حينما تبعث جدولاً ذو بُعدين إلى دالة، يجب أن تحددّ حجم البُعد الثاني للجدول في النموذج. هكذا تعمل الأمور، إن الأمر ضروري.

أمر آخر : تلاحظ أن
\InlineCode{playerPosition}
تُسمى 
\InlineCode{pos}
في هذه الدالة. لقد اخترت اختصار الاسم لكي تسهل كتابته بما أننا سنحتاج إلى كتابته عدّة مرات، لكي لا نتعب.

فلنبدأ باختبار الإتجاه الذي نريد التوجّه إليه و ذلك باستعمال
\InlineCode{switch}
ضخم :

\begin{Csource}
switch(direction)
{
	case UP:
	/* etc */
\end{Csource}

\subsubsection{فلننطلق في رحلة من الاختبارات المجنونة !}

يجب الآن أن نكتب الاختبارات الخاصة بكلّ حالة ممكنة محاولين ألا ننسى أية واحدة. 

هكذا تقوم الخطة التي أعتمدها : أختبر كل الحالات الممكنة للاصطدامات حالة بحالة، و ما إن أكشف عن اصطدام (أي أن اللاعب غير متمكّن من التحرّك) أضع الأمر
\InlineCode{break}
لأخرج من الـ\InlineCode{switch}،
و بهذا أمنع التحرّك.

هذا مثال عن كلّ حالات الاصطدام المتواجدة للاعب يريد التحرّك نحو الأعلى :

\begin{itemize}
	\item اللاعب متواجد أصلاً في أقصى أعلى الخريطة.
	\item يوجد جدار فوق اللاعب.
	\item يوجد صندوقان معاً فوق اللاعب (و هو غير قادر على دفع صندوقين).
	\item يوجد صندوق فوق اللاعب و الصندوق متواجد في الحافة العلوية للخريطة.
\end{itemize}

إذا مرّت كلّ هذه الاختبارات، يمكننا تحريك اللاعب. 

سأريك الاختبارات اللازمة من أجل التحرّك نحو الأعلى. من أجل الحالات الأخرى، يكفي تعديل الشفرة قليلا.

\begin{Csource}
if (pos->y - 1 < 0) // If the player exceeds the screen, we stop
	break;
\end{Csource}

نبدأ بالتحقق ما إن كان اللاعب متواجداً أعلى النافذة. بالفعل، لو نحاول أن نطلب الخانة 
\InlineCode{map[5][-1]}
مثلاً، سيتوقف البرنامج بشكل خاطئ !\\
نبدأ إذا بالتأكد من أننا لن "نتجاوز" الشاشة.

بعد ذلك :

\begin{Csource}
if (map[pos->x][pos->y - 1] == WALL) // If there's a wall, we stop
	break;
\end{Csource}

هنا أيضاً، الأمر بسيط. نتحقق من عدم وجود جدار فوق اللاعب. إذا كان هناك واحد، نتوقّف
(\InlineCode{break}).

بعد ذلك (حافظ على عينيك): 

\begin{Csource}
// If we want to push a box, we have to verify that there's no wall behind it (or another box, or the world's limit)
if ((map[pos->x][pos->y - 1] == BOX || map[pos->x][pos->y -1] == BOX_OK) && (pos->y - 2 < 0 || map[pos->x][pos->y - 2] == WALL || map[pos->x][pos->y - 2] == BOX || map[pos->x][pos->y - 2] == BOX_OK))
	break;
\end{Csource}

هذا الاختبار الضخم يمكن ترجمته كالتالي : "إذا كان هناك صندوق فوق اللاعب (أو صندوق في الوضعية المناسبة) و إذا كان فوق هذا الصندوق يوجد إما الفراغ (سنتجاوز من الحافّة العلوية لأننا في أقصى الأعلى)، أو صندوق آخر، أو صندوق في الوضعيّة المناسبة : إذاً لا يمكننا التحرّك : خروج
(\InlineCode{break})".

إذا تمكنّا من عبور هذا الإختبار فنحن قادرون على التحرّك، أوووف !\\
نستدعي اولاً دالة تقوم بتحريك الصندوق إن كنا بحاجة إلى ذلك :

\begin{Csource}
// If we are here, so we can move the player
// We verify if there's a box to move first
moveBox(&map[pos->x][pos->y - 1], &map[pos->x][pos->y - 2]);
\end{Csource}

\subsection{تحريك الصناديق : \texttt{moveBox}}

قررت معالجة تحرّك الصناديق باستعمال دالة أخرى لأن الشفرة تبقى نفسها من أجل الإتجاهات الأربعة. يجب فقط أن نتأكّد بأننا قادرون على التحرّك (هذا ما كنتُ بصدد شرحه).\\
سنبعث للدالة معاملين : محتوى الخانة التي نريد الذهاب إليها و محتوى الخانة التي تليها.

\begin{Csource}
void moveBox(int *firstSquare, int *secondSquare)
{
	if (*firstSquare == BOX || *firstSquare == BOX_OK)
	{
		if (*secondSquare == GOAL)
			*secondSquare = BOX_OK;
		else
			*secondSquare = BOX;
		if (*firstSquare == BOX_OK)
			*firstSquare = GOAL;
		else
			*firstSquare = EMPTY;
	}
}
\end{Csource}

هذه الدالة تقوم بتحديث الخريطة و هي تأخذ كمعاملات مؤشّرات نحو الخانات المعنيّة.\\
سأتركك لتقرأها، فهي سهلة للفهم. لا يجب أن ننسى أننا إذا حرّكنا 
\InlineCode{BOX\_OK}.
يجب تعويض المكان الذي كان به بـ\InlineCode{OBJECTIVE}.
و إلا، إذا كان
\InlineCode{BOX}،
 سنعوّض مكانه بـ\InlineCode{EMPTY}.

\subsubsection{تحريك اللاعب}

نعود للدالة
\InlineCode{movePlayer}.\\
نحن هنا في الحالة الصحيحة، سنقوم بتحريك اللاعب.

كيف نفعل ذلك ؟ هذا أمر سهل :

\begin{Csource}
pos->y--; // Finally, we can move up the player (ouf!)
\end{Csource}

يكفي أن ننقِص من الترتيبة (لأن اللاعب يريد الصعود للأعلى).

\subsection{تلخيص}

كملخّص، هاهي كلّ الاختبارات اللازمة من أجل الصعود إلى الأعلى :

\begin{Csource}
switch(direction)
{
	case UP:
	if (pos->y - 1 < 0) // If the player exceeds the screen, we stop
		break;
	if (map[pos->x][pos->y - 1] == WALL) // If there's a wall, we stop
		break;
	// If we want to push a box, we have to verify that there's no wall behind it (or another box, or the world's limit)
	if ((map[pos->x][pos->y - 1] == BOX || map[pos->x][pos->y - 1] == BOX_OK) && (pos->y - 2 < 0 || map[pos->x][pos->y - 2] == WALL || map[pos->x][pos->y - 2] == BOX || map[pos->x][pos->y - 2] == BOX_OK))
		break;
	// If we are here, so we can move the player
	// We verify if there's a box to move first
	moveBox(&map[pos->x][pos->y - 1], &map[pos->x][pos->y - 2]);
	pos->y--; // Finally, we can move up the player (ouf!)
	break;
\end{Csource}

سأترك لك عناء نقل الشفرة و تعديلها من أجل الحالات الأخرى (إحذر، عليك ملائمة الشفرة، ليست مطابقة تماما في كلّ مرّة !).

ها قد انتهينا من كتابة شفرة اللعبة !\\
حسناً، قريباً : بقي لنا أن نرى دالة التحميل و حِفظ المستويات.
سنرى بعد ذلك كيف نقوم بكتابة شفرة مُنشئ المستويات. كن متأكّدا، سيكون هذا سريعا !

\section{تحميل و حِفظ المستويات}

الملف
\InlineCode{files.c}
يحتوي على دالتين :

\begin{itemize}
	\item \InlineCode{loadLevel}.
	\item \InlineCode{saveLevel}.
\end{itemize} 
فلنبدأ بتحميل المستوى.

\subsection{تحميل المستوى \texttt{loadLevel}}

هذه الدالة تأخذ معاملا : الخريطة. هنا أيضاً، يجب تحديد مقدار البُعد الثاني للجدول لأننا نتكلم عن جدول ذو بعدين.\\
الدالة تُرجع متغيرا منطقيا : "صحيح" إذا تم التحميل بنجاح، "خطأ" إذا فشل.

النموذج إذا هو :

\begin{Csource}
int loadLevel(int level[][NB_BLOCKS_HEIGHT]);
\end{Csource}

فلنرى بداية الدالة :

\begin{Csource}
FILE* file = NULL;
char fileLine[NB_BLOCKS_WIDTH * NB_BLOCKS_HEIGHT + 1] = {0};
int i = 0, j = 0;
file = fopen("levels.lvl", "r");
if (file == NULL)
	return 0;
\end{Csource}

نقوم بإنشاء جدول للتخزين المؤقّت للنتيجة الخاصة بتحميل المستوى.\\
نفتح الملف بوضع "قراءة فقط"
(\InlineCode{r}).
نوقف الدالة و ذلك بإرجاع القيمة 0 ("خطأ") إذا فشلت عملية فتح الملف. عملية تقليديّة.

الملف
\InlineCode{levels.lvl}
يحتوي على سطر و الذي هو عبارة عن تتالي أرقام. كل رقم يمثّل خانة من المستوى، مثلا :

\begin{Console}
11111001111111111400000111110001100103310101101100000200121110 [...]
\end{Console}

يمكننا إذا قراءة هذا السطر باستعمال
\InlineCode{fgets} :

\begin{Csource}
fgets(fileLine, NB_BLOCKS_WIDTH * NB_BLOCKS_HEIGHT + 1, file);
\end{Csource}

سنقوم بتحليل محتوى
\InlineCode{fileLine}.
نحن نعرف أن أول 12 محرفا تمثل السطر الأول، الـ12 محرفا الموالية تمثل السطر الموالي، إلى آخره.

\begin{Csource}
for (i = 0 ; i < NB_BLOCKS_WIDTH ; i++)
{
	for (j = 0 ; j < NB_BLOCKS_HEIGHT ; j++)
	{
		switch (fileLine[(i * NB_BLOCKS_WIDTH) + j])
		{
			case '0':
			level[j][i] = 0;
			break;
			case '1':
			level[j][i] = 1;
			break;
			case '2':
			level[j][i] = 2;
			break;
			case '3':
			level[j][i] = 3;
			break;
			case '4':
			level[j][i] = 4;
			break;
		}
	}
}
\end{Csource}

بواسطة عملية حسابية بسيطة، نأخذ الحرف الذي يهمّنا في
\InlineCode{fileLine}
و نحلل قيمته.

\begin{warning}
إنها "حروف" مخزّنة في الملف. ما أريد أن أقوله بهذا هو أن 
\InlineCode{'0'}
مخزّن كمحرف
\InlineCode{'0'} \textenglish{ASCII}
و أن قيمته ليست 0 !\\
لنحلل الملف، يجب الاختبار بـ\InlineCode{case '0'}
 و ليس 
\InlineCode{case 0} !
احذر من الخلط بين الحروف و الأرقام !
\end{warning}

يقوم الـ\InlineCode{switch}
بالتحويل : 
\InlineCode{'0'} $ \Leftarrow $ \InlineCode{0}،
\InlineCode{'1'} $ \Leftarrow $ \InlineCode{1}،
 إلخ. يقوم بوضع الكلّ في الجدول
\InlineCode{map}.
الخريطة تسمّى
\InlineCode{level}
في هذه الدالة لكن هذا لا يغيّر أي شيء.

ما إن يتم هذا، يمكننا غلق الملف و إرجاع القيمة 1 لنقول أن كلّ شيء تمّ على ما يُرام.
\begin{Csource}
fclose(file);
return 1;
\end{Csource}

أخيراً، تحميل المستوى من الملف لم يكن معقداً. الفخّ الوحيد الذي وُجب تجنّبه هو التفكير في تحويل القيمة
\textenglish{ASCII} \InlineCode{'0'}
إلى الرقم
\InlineCode{0}
(نفس الشيء بالنسبة لـ\InlineCode{1}، \InlineCode{2}، \InlineCode{3}، \InlineCode{4}، \dots).

\subsection{حِفظ المستوى \texttt{saveLevel}}

هذه الدالة أسهل :

\begin{Csource}
int saveLevel(int level[][NB_BLOCKS_HEIGHT])
{
	FILE* file = NULL;
	int i = 0, j = 0;
	file = fopen("levels.lvl", "w");
	if (file == NULL)
	return 0;
	for (i = 0 ; i < NB_BLOCKS_WIDTH ; i++)
	{
		for (j = 0 ; j < NB_BLOCKS_HEIGHT ; j++)
		{
			fprintf(file, "%d", level[j][i]);
		}
	}
	fclose(file);
	return 1;
}
\end{Csource}

استعملت الدالة
\InlineCode{fprintf}
من أجل "ترجمة" أعداد الجدول إلى حروف
\textenglish{ASCII}.
كانت هنا الصعوبة الوحيدة : تجب عدم كتابة
\InlineCode{0}
و إنما
\InlineCode{'0'}.

\section{مُنـشئ المستويات}

هذا الأخير سهل الكتابة أكثر مما تتخيل.\\
بالمناسبة، هذه تقنية تسمح بزيادة عمر لعبتنا، فلما نتجاهلها ؟

هكذا تسري الأمور :

\begin{itemize}
	\item نستعمل الفأرة لوضع الكتل التي نريدها في النافذة.
	\item النقر باليمين يسمح بمسح الكتلة الذي تتواجد فوقها الفأرة.
	\item النقر باليسار يسمح بوضع شيء على الخريطة. هذا الشيء يكون مخزّناً : افتراضيّا، نقوم بوضع الجدران بالنقر بيسار الفأرة. يمكننا تغيير الشيء الذي نريد وضعه في الخريطة بالضغط على الأزرار المتواجدة في لوحة الأرقام :
	\begin{enumerate}
		\item جدار.
		\item صندوق.
		\item منطقة مُستهدفة.
		\item مكان انطلاق 
		\textenglish{Mario}.
	\end{enumerate}
	\item بالضغط على
	\InlineCode{S}
	يتم حفظ المستوى.
	\item يمكننا الرجوع إلى القائمة الرئيسية بالضغط على
	\InlineCode{Esc}.
\end{itemize}

\Picture{Chapter_III-5_Editor}

\subsection{التهيئات}

بشكل عام، تشبه هذه الدالة، الدالة الخاصة باللعبة. ولذلك فقط بدأت في كتابتها باستعمال "نسخ-لصق" لدالة اللعبة، و بعد ذلك قمتُ بنزع ما لا أحتاجُه و أضفت مميزات جديدة.

هذه كانت البداية :

\begin{Csource}
void editor(SDL_Surface* screen)
{
	SDL_Surface *wall = NULL, *box = NULL, *level = NULL, *mario = NULL;
	SDL_Rect position;
	SDL_Event event;
	int cont = 1, leftClickInProgress = 0, rightClickInProgress = 0;
	int currentObject = WALL, i = 0, j = 0;
	int map[NB_BLOCKS_WIDTH][NB_BLOCKS_HEIGHT] = {0};
	// Loading the objects and the level
	wall = IMG_Load("wall.jpg");
	box = IMG_Load("box.jpg");
	level = IMG_Load("level.png");
	mario = IMG_Load("mario_bas.gif");
	if (!loadLevel(map))
		exit(EXIT_FAILURE);
\end{Csource}

هنا تجد تعريف المتغيرات و التهيئات اللازمة.\\
تلاحظ أنني لا أقوم بتحميل إلا 
\textenglish{Mario}
واحد (المتّجه نحو الأسفل). في الواقع، لن نقوم بتوجيه
\textenglish{Mario}
بلوحة المفاتيح و إنما نحتاج إلى ملصق يمثّل وضعية الإنطلاق الخاصة به.

المتغير
\InlineCode{currentObject}
يحفظ الشيء الذي يختاره المُستعمل حالياً. افتراضيّا، هذا الشيء هو
\InlineCode{WALL}.
 أي أننا في البداية إذا نقرنا بالزرّ اليسار سنقوم بوضع جدار، لكن يمكن تغيير هذا بواسطة المستعمل و ذلك بالضغط على 
\InlineCode{1}، \InlineCode{2}، \InlineCode{3}
 أو
\InlineCode{4}.

المتغيرات المنطقية
\InlineCode{leftClickInProgress}
و
\InlineCode{rightClickInProgress}
كما تشير أسماؤها، تسمح بحفظ ما إن كان هناك نقر ياليمين حالياً (أي أن زر الفأرة مضغوط). سأشرح لك المبدأ لاحقاً. على أي حال، هذه التقنية تسمح لنا بإضافة أشياء إلى الخريطة بترك زر الفأرة مضغوطاً، و إلا فسنكون مجبرين على الضغط على الزر عدة مرات من أجل وضع نفس الشيء عدّة مرات في الخريطة في أمكنة مختلفة، و هذا أمر مُتعب قليلا.

أخيراً، يتم تحميل الخريطة المحفوطة حالياً في الملف
\InlineCode{levels.lvl}.
سيكون نقطة انطلاقنا.

\subsection{معالجة الأحداث}

هذه المرة سيكون علينا معالجة كثير من الأحداث المختلفة. هيا بنا، واحداً واحداً.

\subsubsection{\texttt{SDL\_QUIT}}

\begin{Csource}
case SDL_QUIT:
cont = 0;
break;
\end{Csource}

إذا ضغطنا على الزر
\InlineCode{X}،
تتوقف الحلقة و نعود إلى القائمة الرئيسية.\\
ليكن في علمك أن هذا الشيء ليس أحسن حلّ بالنسبة لللاعب : فهو يريد الخروج من اللعبة و ليس الرجوع إلى القائمة الرئيسية. يجب أن نجد حلاً لإيقاف البرنامج و ذلك بإرجاع قيمة خاصّة للدالة الرئيسية مثلاً. سأتركك لتجد حلاً بنفسك.

\subsubsection{\texttt{SDL\_MOUSEBUTTONDOWN}}

\begin{Csource}
case SDL_MOUSEBUTTONDOWN:
if (event.button.button == SDL_BUTTON_LEFT)
{
	// We put the chosen object (wall, box) in the click position
	map[event.button.x / BLOCK_SIZE][event.button.y / BLOCK_SIZE] = currentObject;
	leftClickInProgress = 1; // We put in mind that there's a pushed button
}
else if (event.button.button == SDL_BUTTON_RIGHT) // Right click to erase
{
	map[event.button.x / BLOCK_SIZE][event.button.y /BLOCK_SIZE] = EMPTY;
	rightClickInProgress = 1;
}
break;
\end{Csource}

نبدأ باختبار الزر المضغوط (نرى ما إن كان ضغطاً بالزر الأيسر أو الأيمن) :

\begin{itemize}
	\item إذا كان ضغطا بالزر الأيسر، نقوم بوضع الشيء الحالي
	\InlineCode{currentObject}
	على الخريطة في الموضع الذي تشير إليه الفأرة.
	\item إذا كان ضغطا بالزر الأيمن، نمسح مايوجد في الموضع الحالي للفأرة (نضع 
	\InlineCode{EMPTY}
	كما سبق و قلتُ لك).
\end{itemize}

\begin{question}
كيف نعرف في أي "خانة" من الخريطة نحن متواجدون ؟
\end{question}

نعرف ذلك عن طريق عملية حسابية صغيرة. يكفي أن نأخذ إحداثيات الفأرة
(\InlineCode{event.button.x}
مثلاً) و نقسم هذه القيمة على حجم كتلة
\InlineCode{BLOCK\_SIZE}.\\
هذه قسمة لأعداد صحيحة. و بما أن قسمة الأعداد الصحيحة في لغة 
\textenglish{C}
تُعطي عدداً صحيحا، فنتحصّل بالتأكيد على قيمة توافق خانة من الخريطة.

مثلاً، لو أنني في البيكسل الـ75 من الخريطة (على محور الفواصل
\textenglish{x})،
أقسم هذا العدد على 
\InlineCode{BLOCK\_SIZE}
و التي تساوي هنا 34. 
يكون لدينا هنا :
$$ 75/34=2 $$.
 لا تنس هنا أننا نتجاهل باقي القسمة و نقوم بحفظ الجزء الصحيح فقط لأننا نتكلم عن قسمة أعداد صحيحة.\\
نحن نعلم إذا أننا نتواجد في الخانة رقم 2 (أي الخانة الثالثة لأن الجدول يبدأ من 0، لا تنس ذلك).

مثال آخر : لو أنني في البيكسل العاشر (أي أنني قريب من الحافة)، ستكون لدينا العملية الحسابية التالية :
$$ 10/34=0 $$
أي أننا في الخانة رقم 0  !

بفضل هذه العملية الحسابية البسيطة يمكننا أن نعرف في أي خانة من الخريطة نحن متواجدون.

\begin{Csource}
map[event.button.x / BLOCK_SIZE][event.button.y / BLOCK_SIZE] = currentObject;
\end{Csource}

شيء آخر مهم : إعطاء القيمة 1 للمتغير المنطقي
\InlineCode{leftClickInProgress}
(أو
\InlineCode{rightClickInProgress}
حسب الحالة) يسمح لنا بمعرفة، خلال حدث
\InlineCode{MOUSEMOTION}،
ما إن كان زر الفأرة مضغوطاً خلال الإنتقال.

\subsubsection{\texttt{SDL\_MOUSEBUTTONUP}}

\begin{Csource}
case SDL_MOUSEBUTTONUP: // We disable the boolean which indicates that there's a clicked button
if (event.button.button == SDL_BUTTON_LEFT)
	leftClickInProgress = 0;
else if (event.button.button == SDL_BUTTON_RIGHT)
	rightClickInProgress = 0;
break;
\end{Csource}

الحدث
\InlineCode{MOUSEBUTTONUP}
يقوم ببساطة بإعادة القيمة 0 للمتغير المنطقي. نحن نعرف بأن النقر انتهى و بهذا لا يوجد أي "نقر حالي" بالفأرة.

\subsubsection{\texttt{SDL\_MOUSEMOTION}}

\begin{Csource}
case SDL_MOUSEMOTION:
if (leftClickInProgress) // If we move the mouse and the left button is clicked
{
	map[event.motion.x / BLOCK_SIZE][event.motion.y /BLOCK_SIZE] = currentObject;
}
else if (rightClickInProgress) // The same thing for the right button
{
	map[event.motion.x / BLOCK_SIZE][event.motion.y / BLOCK_SIZE] = EMPTY;
}
break;
\end{Csource}

هنا يمكن لنا رؤية أهمية المتغيرات المنطقية. نختبر حينما نقوم بتحريك الفأرة ما إن كان هناك نقر حالي. إذا كانت هذه هي الحالة، نضع على الخريطة شيئاً ما (أو الفراغ إذا كان نقرا باليمين).\\
هذا يسمحُ لنا بوضع شيء واحد لعدة مرات دون الحاجة إلى إلى النقر في كلّ مرة من أجل كلّ تكرار للشيء، يكفي إذاً أن نُبقي زر الفأرة مضغوطاً بينما نسحبُ هذه الأخيرة.

الأمر واضح : في كلّ مرة نحرّك فيها الفأرة (يكون ذلك ببيكسل واحد)، نختبر ما إن كانت المتغيرات المنطقية مفعّلة. إذا كان الأمر كذلك، نقوم بوضع شيء على الخريطة. و إلاً، لا نقوم بأي شيء.

\paragraph{ملخّص :}
سألخّص التقنية لأنها ستكون مفيدة من أجل برامج أخرى.\\
تسمح هذه التقنية بمعرفة ما إن كان زر الفأرة مضغوطاً بينما يتم تحريك هذه الأخيرة. يمكننا أن نستفيد من هذا الأمر لبرمجة
\textit{السحب و الإفلات}
(\textenglish{drag and drop}).

\begin{enumerate}
	\item خلال حدث
	\InlineCode{MOUSEBUTTONDOWN} :
	نعطي القيمة 1 للمتغير المنطقي
	\InlineCode{clickInProgress}.
	\item خلال حدث 
	\InlineCode{MOUSEMOTION} :
	نختبر ما إن كان المتغير المنطقي 
	\InlineCode{clickInProgress}
	يساوي "صحيح". إذا كان الأمر كذلك فسنعرف أننا نقوم بالسحب باستخدام الفأرة.
	\item  خلال حدث
	\InlineCode{MOUSEBUTTONUP} :
	نعيد القيمة 0 للمتغير المنطقي
	\InlineCode{clickInProgress}
	لأن النقر قد انتهى (إفلات زر الفأرة).
\end{enumerate}

\subsubsection{\texttt{SDL\_KEYDOWN}}

تسمح أزرار لوحة المفاتيح بتحميل و حفظ المستوى و أيضاً بتغيير الشيء المُختار من أجل النقر اليساري بالفأرة. 

\begin{Csource}
case SDL_KEYDOWN:
switch(event.key.keysym.sym)
{
	case SDLK_ESCAPE:
		cont = 0;
		break;
	case SDLK_s:
		saveLevel(map);
		break;
	case SDLK_c:
		loadLevel(map);
		break;
	case SDLK_KP1:
		currentObject = WALL;
		break;
	case SDLK_KP2:
		currentObject = BOX;
		break;
	case SDLK_KP3:
		currentObject = GOAL;
		break;
	case SDLK_KP4:
		currentObject = MARIO;
		break;
}
break;
\end{Csource}

هذه الشفرة سهلة للغاية. نقوم بتغيير الشيء إذا تم الضغط على الأرقام في اللوحة، نقوم بحفظ المستوى إذا تم الضغط على 
\InlineCode{S}
و نقوم بتحميل آخر مستوى تم حفظه بالنقر على
\InlineCode{C}.

\subsection{وقت اللصق !}

ها نحن ذا : لقد أتتممنا كلّ الأحداث.\\
الآن، لم يتبقّ لنا سوى لصق كل عناصر الخريطة بمساعدة حلقتين متداخلتين. الشفرة التالية تشبه الشفرة التي استعملناها في دالة اللعبة. سأعطيها لك لكنّي لن أعيد شرحها هنا :

\begin{Csource}
// Clearing the screen
SDL_FillRect(screen, NULL, SDL_MapRGB(screen->format, 255, 255, 255));
// Placing the objects in the screen
for (i = 0 ; i < NB_BLOCKS_WIDTH ; i++)
{
	for (j = 0 ; j < NB_BLOCKS_HEIGHT ; j++)
	{
		position.x = i * BLOCK_SIZE;
		position.y = j * BLOCK_SIZE;
		switch(map[i][j])
		{
			case WALL:
			SDL_BlitSurface(wall, NULL, screen, &position);
			break;
			case BOX:
			SDL_BlitSurface(box, NULL, screen, &position);
			break;
			case GOAL:
			SDL_BlitSurface(level, NULL, screen, &position);
			break;
			case MARIO:
			SDL_BlitSurface(mario, NULL, screen, &position);
			break;
		}
	}
}
// Updating the screen
SDL_Flip(screen);
\end{Csource}

لا يجب أن ننسى أن نحرر الذاكرة بعد الانتهاء من الحلقة الرئيسية بالشكل اللازم (باستعمال
\InlineCode{SDL\_FreeSurface}) :

\begin{Csource}
SDL_FreeSurface(wall);
SDL_FreeSurface(box);
SDL_FreeSurface(level);
SDL_FreeSurface(mario);
\end{Csource}

حسناً، إنتهينا من التنظيف !
