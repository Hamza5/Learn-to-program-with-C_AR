\chapter{حسابات سهلة}

كما قلت لك في الفصل السابق: جهازك ماهو إلا آلة حاسبة كبيرة. سواء كنت تسمع الموسيقى، تشاهد فلمًا أو تلعب لعبة، فإن الحاسوب ينجز الحسابات طيلة الوقت.

هذا الفصل سيساعدك على التعرف على معظم الحسابات التي يقوم بها الجهاز. سنعيد استعمال ما نحن بصدد تعلّمه عن عالم المتغيرات. الفكرة هي أننا سنقوم بعمليات على المتغيرات: نجمعها، نضربها، نخزّن النتائج في متغيرات أخرى، إلخ.

حتى وإن لم تكن من هواة الرياضيات، فإن هذا الفصل إلزامي ولا مفرّ منه.

\section{الحسابات القاعدية}

بالرغم من قدرة الجهاز الواسعة إلا أنه في الأساس يتعمد في حساباته على عمليات بسيطة للغاية وهي:

\begin{itemize}
  \item الجمع،
  \item الطرح،
  \item القسمة،
  \item الضرب،
  \item الترديد
(\textenglish{Modulo})
(سأشرح لاحقا ما الّذي يعنيه إذا لم تكن تعرفه الآن).
\end{itemize}

إن كان بودك القيام بحسابات أكثر تعقيدا (كالأسس واللوغاريثم وماشابه)، يجب عليك إذا برمجتها أو بمعنى آخر:
\textbf{توضح للجهاز كيف يقوم بها}.\\
لحسن الحظ، سترى لاحقًا في هذا الفصل أنه توجد مكتبة في لغة \textenglish{C}،
تحتوي على دوال رياضية جاهزة. لن يكون عليك إعادة كتابتها إلا إذا أردت فعل ذلك تطوّعيا أو كنت أستاذ رياضيات.

لنبدأ بالعملية الأسهل وهي الجمع.\\
طبعا في الجمع نحتاج الرمز +.\\
يجب وضع نتيجة الجمع في متغير ولهذا سنقوم بإنشاء متغير اسمه مثلا
\InlineCode{result}
من نوع
\InlineCode{int}
و نقوم بالحساب:

\begin{Csource}
  int result = 0;
  result = 5 + 3;
\end{Csource}

لا يجب أن تكون محترفا في الحساب الذهني لتعرف أن النتيجة ستكون 8 بعد تشغيل البرنامج.\\
بالطبع البرنامج لن يظهر أية نتيجة باستعمال هذه الشفرة المصدرية. إذا أردت معرفة محتوى المتغير
\InlineCode{result}
عليك باستعمال الدالة
\InlineCode{printf}
التي تجيد كيفية استخدامها جيدًا الآن:

\begin{Csource}
  printf("5 + 3 =  %d", result);
\end{Csource}

و هذا ما سيظهر على الشاشة:

\begin{Console}
  5 + 3 = 8
\end{Console}

و هكذا ننهى عملية الجمع بسهولة.\\
الأمر مماثل بالنسبة للعمليات الأخرى، نحتاج تغيير الرمز ليس إلا:

\begin{Table}{2}
  العمليّة & الرمز\\
  الجمع & \texttt{+}\\
  الطرح & \texttt{-}\\
  الضرب & \texttt{*}\\
  القسمة & \texttt{/}\\
  الترديد & \texttt{\%}\\
\end{Table}

إذا كنت قد استعملت من قبل الآلة الحاسبة الخاصة بحاسوبك، فيفترض بك أن تكون متعوّدا على هذه الإشارات. لا يوجد أي شيء صعب بخصوصها باستثناء القسمة والترديد اللذان سأشرحهما فيما يلي بالتفصيل.

\subsection{القسمة}

ينجز الحاسوب عملية القسمة بشكل طبيعيّ عندما لا يوجد أي باق. مثلا العملية
\InlineCode{6 / 2}
تعطينا النتيجة 3، النتيجة صحيحة. حتّى الآن، لا مشكلة.

لكن لو نأخذ الآن عملية قسمة بباقٍ مثل
\InlineCode{5 / 2}
\dots
نتوقع أن النتيجة ستكون $ 2.5 $، ولكن أنظر إلى ما تعطيه الشفرة:

\begin{Csource}
int result = 0;
result = 5 / 2;
printf("5 / 2 =  %d", result);
\end{Csource}

\begin{Console}
  5 / 2 = 2
\end{Console}

هناك مشكل كبير، فنحن نتوقّع أن نحصل على القيمة $ 2.5 $، لكن الحاسوب أعطى القيمة $ 2 $!

هل يا ترى أجهزتنا غبية لهذه الدرجة؟\\
في الواقع، يقوم الجهاز بعملية قسمة صحيحة (إقليدية) أي أنه يحتفظ بالجزء الصحيح فقط الذي هو 2.

\begin{question}
  هه أنا أعرف السبب! لأن المتغير
  \InlineCode{result}
  الذي استخدمناه هو من نوع
  \InlineCode{int}!
  لو استخدمنا النوع
  \InlineCode{double}
  لاستطاع تخزين العدد العشري!
\end{question}

لا، ليس هذا هو السبب! جرب  نفس الشفرة بتغيير نوع النتيجة إلى
\InlineCode{double}
و ستجد بأننا نتحصّل على نفس النتيجة 2 لأن طرفا العملية من نوع
\InlineCode{int}
فإن الحاسوب سيعيد نتيجة من نوع
\InlineCode{int}.

إن أردنا أن يظهر لنا الجهاز القيمة الصحيحة، يجب أن نغير العددين $ 2 $ و$ 5 $ إلى عددين عشريين كالتالي: $ 2.0 $ و$ 5.0  $(قيمتهما هي نفسها لكن الجهاز سيعتبرهما عددين عشريين، وبالتالي هو يظن بأنه يقوم بقسمة عددين عشريين):

\begin{Csource}
  double result = 0;
  result = 5.0 / 2.0;
  printf("5 / 2 =  %f", result);
\end{Csource}

\begin{Console}
  5 / 2 = 2.500000
\end{Console}

هنا العدد صحيح بالرغم من وجود عدة أصفار في نهاية العدد، لكنّ القيمة تبقى نفسها.

فكرة القسمة الإقليدية التي يقوم بها الحاسوب مهمة، تذكّر أنه بالنسبة للحاسوب:

\begin{itemize}
  \item $ 5 / 2 = 2 $،
  \item $ 10 / 3 = 3 $،
  \item $ 4 / 5 = 0 $.
\end{itemize}

هذا مفاجئ بعض الشيء، لكنّها طريقته في التعامل مع الأعداد الصحيحة.

إن أردت الحصول على نتيجة عشريّة، فيجب أن يكون حدّا العملية عشريّين:

\begin{itemize}
  \item $ 5.0 / 2.0 = 2.5 $،
  \item $ 10.0 / 3.0 = 3.33333 $،
  \item $ 4.0 / 5.0 = 0.8 $.
\end{itemize}

يمكن القول أن الجهاز يطرح على نفسه السؤال: "كم يوجد من 2 في العدد 5؟" طبعا يوجد 2 فقط.

و لكن أين الباقي من العملية؟ لأنني لما أقول 5 هي أثنين من 2 ، يبقى 1 طبعا، كيف لنا أن نسترجعه؟\\
هنا يتدخل الترديد الذي كلمتك عنه.

\subsection{الترديد}

هو عبارة عن عملية حسابية تسمح بالحصول على باقي عملية القسمة، وهي عملية غير معروفة مقارنة بالعمليات الأربع الأخرى، لكن الجهاز يعتبرها من العمليات القاعدية، ويمكن اعتبارها حلا لمشكل قسمة الأعداد الطبيعية.

كما قلت لك الترديد يمثل بالرمز
\InlineCode{\%}.\\
إليكم بعض الأمثلة:

\begin{itemize}
  \item $ 5 \% 2 = 1 $،
  \item $ 14 \% 3 = 2 $،
  \item $ 4 \% 2 = 0 $.
\end{itemize}

الترديد
\InlineCode{5 \% 2}
هو باقي العملية
\InlineCode{5 / 2}
مما يعني أن الجهاز يقوم بالعملية
\InlineCode{5 = 2 * 2 + 1}
حيث أن 1 هو الباقي والذي يقوم بإرجاعه الترديد.

نفس الشيء بالنسبة للعملية
\InlineCode{14 \% 3}،
العملية هي
\InlineCode{14 = 3 * 4 + 2}
(الترديد يعطي القيمة  2). أخيرا، من أجل
\InlineCode{4 \% 2}،
القسمة تامة، فلا يوجد باقي، لهذا يعطي الترديد القيمة 0.

حسنا، لا يوجد ما يمكنني إضافته بخصوص عملية الترديد. كان هذا فقط شرحا لمن لا يعرفها.

لدي خبر جيد آخر، وهو أننا أتممنا كلّ عمليات الحساب القاعدية وتخلصنا من درس الرياضيات!

\subsection{عمليات على المتغيرات}

الشيء الجيد هو أنه بعد أن تعلمت كيف تستخدم العمليات القاعدية، يمكنك الآن أن تتعلّم كيفية القيام بهذه العمليات على المتغيرات.\\
لا شيء يمكنه منعك من كتابة الشفرة التالية:

\begin{Csource}
  result = number1 + number2;
\end{Csource}

هذا السطر يعمل على جمع المتغيرين
\InlineCode{number1}
و
\InlineCode{number2}
ثم يخزن النتيجة في المتغير
\InlineCode{result}.

هنا بدأت الأمور الممتعة تظهر، وحقيقة، مستواك الحالي يسمح لك ببرمجة آلة حاسبة بسيطة. نعم، نعم، أؤكّد لك ذلك!

تخيل وجود برنامج يطلب من المستخدم إدخال عددين، ثم يقوم بتخزينهما في متغيرين، ثم يجمع هذين المتغيرين ويخزن النتيجة في متغير اسمه
\InlineCode{result}.
لم يبق سوى إظهار النتيجة على الشاشة في وقت لا يتمكّن فيه المستخدم حتى من تخمين النتيجة.

حاول كتابة هذا البرنامج البسيط، إنّه سهل وسيكون تدريبا لك!

إليك الجواب:

\begin{Csource}
int main(int argc, char * argv[])
{
  int result = 0, number1 = 0, number2 = 0;

  // We request the two numbers from the user :

  printf("Enter the first number : ");
  scanf("%d", &number1);
  printf("Enter the second number : ");
  scanf("%d", &number2);

  // We calculate the result :

  result = number1 + number2;

  // We display the result on the screen :

  printf("%d + %d = %d\n", number1, number2, result);

  return 0;
}
\end{Csource}

\begin{Console}
  Enter the first number : 30
  Enter the second number : 25
  30 + 25 = 55
\end{Console}

بدون أن تشعر، لقد أنشأت أول برنامج لك ذو فائدة. إنّه قادر على جمع عددين وإظهارا النتيجة على الشاشة!

يمكنك التجريب باستخدام أعداد أخرى (يجب ألا تتجاوز الحد الأقصى لتحمّل نوع \InlineCode{int})
و سيقوم الحاسوب بالحساب بشكل سريع جدًا لا يتجاوز بعض أجزاء من المليار من الثانية!

أنصحك أيضًا بتجريب العمليات الأخرى (الطرح، القسمة والضرب) لكي تتدرب. لن يكون هذا متعبا إلّا بقدر تغيير إشارة أو اثنتين. يمكنك أيضًا إضافة متغير ثالث وجمع ثلاثة متغيرات دفعة واحدة. سيشتغل البرنامج دون مشاكل:

\begin{Csource}
result = number1 + number2 + number3;
\end{Csource}

\section{الاختصارات}

كما وعدتك، لا توجد عمليات أخرى لنتعلّمها اليوم لأن هذه هي كلّ العمليات الموجودة! بهذه العمليات البسيطة يمكنك برمجة أي شيء تريده. أعلم أنّه يصعب عليك التصديق لو قلت لك أن لعبة ثلاثية الأبعاد ليست في النهاية سوى مجموعة من عمليات الجمع والطرح\dots
لكنها الحقيقة.

توجد طرق في لغة \textenglish{C}
تسمح لنا باختصار كتابة بعض العمليات. لماذا نستعمل هذه الاختصارات؟ لأننا نحتاج في غالب الأحيان من كتابة عمليات مكرّرة. ستفهم ما أريد قوله حينما ترون ما نسمّيه بالزيادة.

\subsection{الزيادة (\textenglish{Incrementation})}

في غالب الأحيان ستضطر إلى إضافة 1 إلى محتوى متغير. وبالتقدّم في برنامجك، تكون لديك متغيرات يزيد محتواها في كلّ مرة بـ1.

نفترض أن لديك متغيرا يحمل اسم
\InlineCode{number}،
هل تعرف كيف تضيف له 1 دون أن تعرف محتواه؟

إليك ما يجب عليك فعله:

\begin{Csource}
number = number + 1;
\end{Csource}

ما الذي يحصل هنا؟ نقوم بالحساب
\InlineCode{number + 1}
ثم نخزن الناتج في المتغير
\InlineCode{number}!
و منه فإن كان المتغير يحمل القيمة 4 فهو بعد العملية يحمل القيمة 5. لو أنه كان يحمل القيمة 8، فهو الآن يحمل القيمة 9، إلخ.

هذه العملية تتكرر كثيرا. وبما أن المبرمج شخص كسول، سيتعبه أمر كتابة اسم المتغير مرتين في نفس التعليمة (نعم هذا أمر متعب!). لهذا تم اختراع اختصار لهذه العملية بما نسميه بـ\textbf{الزيادة }
(\textenglish{Incrementation})
التعليمة أسفله تعطي تماما نفس نتيجة التعليمة السابقة:

\begin{Csource}
  number++;
\end{Csource}

هذا السطر له نفس وظيفة السطر السابق الذي كتبناه قبل قليل، أليس مختصرا وقصيرا؟ إنه يعني "إضافة 1 لمتغير". يكفي إذا أن نرفق باسم المتغير
\InlineCode{number}
الاشارة + مرتين، مع عدم نسيان الفاصلة المنقوطة الخاصة بنهاية التعليمة.

هذه العملية ستساعدنا كثيرا مستقبلا لأننا سنضطر للقيام بعملية الزيادة كثيرا.

\begin{information}
إذا كنت دقيق الملاحظة، كنت لتلحظ أن إشارتي
++
متواجدتان أيضًا في اسم اللغة
\textenglish{C++}.
أنت الآن قادر على أن تفهم السر وراء ذلك! \textenglish{C++}
تعني أننا نتكلم عن لغة \textenglish{C}
"مع زيادة". عمليّا، يسمح لنا \textenglish{C++}
بالبرمجة بطريقة مختلفة، لكن لا يعني أنه "أفضل" من \textenglish{C}.
هو فقط مختلف.
\end{information}

\subsection{الإنقاص (\textenglish{Decrementation})}

إنّها بكلّ بساطة عكس عملية الزيادة، فهي تقوم بإنقاص 1 من متغير.\\
بالرغم من أن عملية الزيادة هي أكثر استعمالًا إلا أن عملية الإنقاص تبقى شائعة أيضا.

إليكم كيف ننقص 1 من متغير بالشكل "الطويل":

\begin{Csource}
  number = number - 1;
\end{Csource}

و في شكلها المختصر:

\begin{Csource}
  number--;
\end{Csource}

ربّما كان بإمكانك تخمين ذلك وحدك! بدل وضع إشارة
\InlineCode{++}
نضع إشارة
\InlineCode{{-}{-}}.
إذا كان محتوى المتغير هو 5 فسيصبح بعد الإنقاص يساوي 4.

\subsection{الاختصارات الأخرى}

توجد اختصارات أخرى تعمل بنفس المنطلق. هذه الاختصارات تصلح لكل العمليات القاعدية:
\InlineCode{+}
\InlineCode{-}
\InlineCode{*}
\InlineCode{/}
\InlineCode{\%}.
هي تساعدنا على تجنب تكرار نفس اسم المتغير في نفس التعليمة.\\
لضرب محتوى المتغير في 2 مثلا نقوم بالتالي:

\begin{Csource}
  number = number * 2;
\end{Csource}

و بالشكل المختصر:

\begin{Csource}
  number *= 2;
\end{Csource}

بالطبع إن كان للمتغير القيمة $ 5 $ قبل إجراء العملية فسيحمل الآن $ 10 $ بعد هذه التعليمة.\\
بالنسبة لباقي العمليات القاعدية، فالمبدأ نفسه. إليك برنامجا صغيرا كمثال:

\begin{Csource}
int number = 2;
number += 4; // number = 6 ...
number -= 3; // ... number = 3
number *= 5; // ... number = 15
number /= 3; // ... number = 5
number %= 3; // ... number = 2 (because 5 = 1 * 3 + 2)
\end{Csource}

\textit{(لا تتذمر فبعض الحسابات الذهنيّة لن تقتل شخصًا!)}

الشيء الجيد هنا أنه يمكننا استعمال اختصارات على كلّ العمليات القاعدية، فيمكننا أن نجمع، نطرح، نضرب أيّ عدد.\\
هي اختصارات عليك تعلّمها إن كان البرنامج الذي تكتبه يحتوي الكثير من التعليمات المكرّرة.

تذكّر أيضًا أن عملية الزيادة هي الاختصار الأكثر استعمالًا.

\section{المكتبة الرياضياتيّة}

في لغة \textenglish{C}
هناك دائما ما نسميه بالمكتبات القياسية
(\textenglish{Standard libraries})،
 وهي المكتبات التي تستخدم على الدوام. إنّها مكتبات قاعدية تستخدم كثيرا.

أذكرك بما قلت سابقا، المكتبة هي مجموعة دوال جاهزة. هذه الدوال تمت كتابتها من طرف مبرمجين قبلك، وهي تساعدك على تجنب إعادة اختراع العجلة في كلّ برنامج جديد.

في الواقع، العمليات الخمس القاعدية الّتي رأيناها هي أقلّ من أن تكون كافية. إذا لم تفهم هذا، فربّما قد تكون صغيرا في السنّ أو لم تتعلّم الكثير عن الرياضيّات في حياتك. المكتبة الرياضياتيّة تحوي العديد من الدوال الأخرى الّتي قد تحتاجها.


أعطيك مثالا، لغة \textenglish{C}
لا تحتوي على عملية الأس! كيف نحسب المربع؟ يمكنك كتابة العملية
\InlineCode{$5~\hat{}~2$}
في برنامجك لكن الجهاز لن يفهمها أبدًا لأنّه لا يعرف مالّذي تعنيه هذه، إلا إن قمت بشرح العملية له باستخدام المكتبة الرياضياتيّة!

يمكننا الاستعانة بالدوال الجاهزة في المكتبة الرياضياتيّة، لكن لا تنس كتابة توجيهات المعالج القبلي الخاصة بها في بداية كل برنامج:

\begin{Csource}
#include <math.h>
\end{Csource}

ما إن تكتب السطر السابق حتّى تصبح قادرًا على استخدام كل الدوال المتوفرة في هذه المكتبة.

لديّ نيّة في عرضها لك الآن.\\
حسنا، بما أنّه يوجد الكثير منها، فلا يمكنني إنشاء قائمة كاملة هنا. من جهة لأنّ هذا سيكون كثيرا للفهم، ومن ناحية أخرى، فأصابعي  المسكينة ستذوب قبل إنهاء كتابة هذا الفصل! سأريك إذن الدوال الرئيسيّة فقط، أي الّتي تبدو أكثر أهميّة.

\begin{information}
ربّما قد لا يكون لديك مستوى  الرياضيات اللازم لفهم ما تفعله هذه الدوال. إن كان هذا هو حالك، فلا تقلق. قم بالقراءة فقط، فهذا لن يضرّك فما يلي.\\
على الرغم من ذلك، أقدّم لك نصيحة مجّانيّة: كن منتبها في دروس الرياضيات، لا نقول هذا من دون سبب، هذا سيفيدك في النهاية.
\end{information}

\subsection{\texttt{fabs}}

هذه الدالة تحسب القيمة المطلقة للرقم، ونرمز لها بالشكل التالي:
\textenglish{|x|}.\\
القيمة المطلقة لعدد هو قيمته الموجبة:

\begin{itemize}
  \item إعطاء العدد $ -52 $ للدالة يجعلها ترجع القيمة $ 52 $،
  \item إعطاء العدد $ 52 $ للدالة يجعلها تعيد $ 52 $.
\end{itemize}

باختصار، تعيد دائما العدد الموجب الموافق لما أعطيته لها.

\begin{Console}
double absolute = 0, number = -27;
absolute = fabs(number); // absolute = 27
\end{Console}

هذه الدالّة تعيد
\InlineCode{double}،
لذا فالمتغيّر
\InlineCode{absolute}
يجب أن يكون من نوع
\InlineCode{double}.

\begin{information}
هناك دالة اخرى مماثلة لـ\InlineCode{fabs}
تسمى
\InlineCode{abs}،
نجدها في
\InlineCode{stdlib.h}.\\
إنّها تعمل بنفس طريقة الأولى إلا أنها تعمل مع الأعداد الصحيحة، فهي تعيد
\InlineCode{int}.
\end{information}

\subsection{\texttt{ceil}}

هذه الدالّة تعطي أول عدد طبيعي بعد العدد العشري الذي نعطيه لها. يمكن القول أنها تدوّر العدد دائما إلى العدد الذي يعلوه في الجزء الصحيح.\\
لو نعطيها مثلا العدد $ 26.512 $ فستعطينا العدد $ 27 $.

الدالة تعمل بنفس الطريقة وتعيد
\InlineCode{double}
أيضا:

\begin{Csource}
double above = 0, number = 52.71;
above = ceil(number); // Above = 53
\end{Csource}

\subsection{\texttt{floor}}
هذه عكس السابقة، تعيد العدد الأقل مباشرة في الجزء الصحيح.\\
إذا أعطيتها مثلا العدد $ 37.91 $ تعطيني العدد $ 37 $، يعني الجزء الصحيح.

\subsection{\texttt{pow}}

هذه خاصة بحساب قوى عدد (الأسس). يجب أن تعطيها قيمتين، الأولى هي العدد الذي تريد إجراء العملية عليه والثانية هي القوة الّتي يجب رفع العدد إليها. هذا مخطط الدالة:

\begin{Csource}
pow(number, power);
\end{Csource}

كمثال: "2 قوة 3" (الّتي نكتبها عادة
\InlineCode{$2~\hat{}~3$}
على الحاسوب) هو الحساب
$ 2 \times 2 \times 2 $
الّذي يعطي النتيجة 8:

\begin{Csource}
double result = 0, number = 2;
result = pow(number, 3); // result = 2^3 = 8
\end{Csource}

\subsection{\texttt{sqrt}}

هذه الدالة تحسب الجذر التربيعي لعدد، تعيد
\InlineCode{double}.

\begin{Csource}
double result = 0, number = 100;
result = sqrt(number); // Result = 10
\end{Csource}

\subsection{\texttt{sin}، \texttt{cos}، \texttt{tan}}

إنّها الدوال المثلثية الثلاث الشهيرة.\\
طريقة عملها هي نفسها، تعيد
\InlineCode{double}.

هذه الدوال تأخذ قيما بـ\textbf{الراديان}
(\textenglish{Radians}).

\subsection{\texttt{asin}، \texttt{acos}، \texttt{atan}}

و هي الدوال
\textenglish{arcsin}، \textenglish{arccos}، \textenglish{arctan}،
دوال مثلثية أخرى.\\
تُستخدم بنفس الطريقة وتعيد
\InlineCode{double}
أيضا.

\subsection{\texttt{exp}}

هذه الدالة تحسب قيمة الدالة الأسيّة ذات الأساس
\textenglish{e}
لعدد معين.\\
تعيد
\InlineCode{double}.

\subsection{\texttt{log}}

هذه الدالة تحسب اللوغاريتم النيبيري لعدد معين. (الّذي نرمز له أيضا بـ"\textenglish{ln}")

\subsection{\texttt{log10}}

هذه الدالة تحسب اللوغاريتم ذو الأساس 10 لعدد.

\section*{ملخّص}

\begin{itemize}
  \item الحاسوب ما هو سوى
\textbf{آلة حاسبة كبيرة}: كل ما يجيد فعله هو القيام بالعمليّات.
  \item العمليات التي يجيدها الحاسوب
\textbf{قاعدية جدا}: الضرب، القسمة، الجمع، الطرح والترديد (باقي القسمة).
  \item بالإمكان
\textbf{إجراء عمليات على المتغيرات}،
الحاسوب سريع جدًا في هذا النوع من العمليات.
  \item \textbf{الزيادة}
(\textenglish{Incrementation})
هي عملية إضافة الرقم 1 إلى متغير. نكتبها
\InlineCode{variable++}.
  \item \textbf{الإنقاص}
(\textenglish{Decrementation})
هي عملية طرح الرقم 1 من متغير. نكتبها
\InlineCode{variable{-}{-}}.
  \item لزيادة عدد العمليات التي يمكن للحاسوب القيام بها، نستعمل
\textbf{المكتبة الرياضيّاتيّة}
(أي\\
\InlineCode{\#include <math.h>})
  \item تحتوي هذه المكتبة على
\textbf{دوال رياضيّاتيّة متقدّمة}
كالأسّ والجذر واللوغاريثم وغيرها.
\end{itemize}
